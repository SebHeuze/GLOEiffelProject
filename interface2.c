#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 2.3 (Thursday July 11th 2007) [Antoine-Auguste Parmentier]
Copyright (C), 1994-2002 - INRIA - LORIA - ESIAL UHP Nancy 1 - FRANCE
Copyright (C), 2003-2005 - INRIA - LORIA - IUT Charlemagne Nancy 2 - FRANCE
D.COLNET, P.RIBET, C.ADRIAN, V.CROIZIER F.MERIZEN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: 
*/

#ifdef __cplusplus
}
#endif
#include "interface.h"
#ifdef __cplusplus
extern "C" {
#endif

/*STRING*/T6 r7is_equal(se_dump_stack*caller,T7* C,T0* a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"is_equal"" STRING",1,2,"%R7%other%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E0C704/*l199c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A03608/*l54c4\any.e*/);
ac_req((a1)!=((void*)((void*)0)),"other /= Void");
fd.assertion_flag=1;
}
if(((ds.p=0x00E0CC0E/*l204c7\string.e*/),((/*RF2*/(C)->_count/*i3p*/))==(r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0CC1E/*l204c15\string.e*/))))))){
(ds.p=0x00E0CD0A/*l205c5\string.e*/);
R=((T6)(r9fast_memcmp(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0CD46/*l205c35\string.e*/))))->_storage/*i3p*/),(/*RF2*/(C)->_count/*i3p*/))));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A03972/*l57c57\any.e*/);
ac_ens((T6)((!(((T0*)(t[(C)->id]))==((void*)((T0*)(t[((T7*)a1)->id])))))||((T6)((R)==(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,a1,0x01A03994/*l57c74\any.e*/))),(T0*)C))))),"commutative");
(ds.p=0x04401320/*l19c16\comparable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,C),a1)))),(T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,((T7*)ci(7,a1,0x04401372/*l19c57\comparable.e*/))),(T0*)C)))))),"trichotomy");
(ds.p=0x04601C16/*l28c11\hashable.e*/);
ac_ens((T6)((!(R))||((T6)((r7hash_code(&ds,C))==(r7hash_code(&ds,se_i7(&ds,((T7*)ci(7,a1,0x04601C3E/*l28c31\hashable.e*/)))))))),"Result implies hash_code = other.hash_code");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T6 r7is_default(se_dump_stack*caller,T7* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_default"" STRING",1,1,"%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A08404/*l132c2\any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x01A08D08/*l141c4\any.e*/);
R=((T6)((C)==((void*)(r7default(&ds,C)))));
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7set_count(se_dump_stack*caller,T7* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"set_count"" STRING",1,1,"%R7%new_count%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E87304/*l2163c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E8751C/*l2165c14\string.e*/);
ac_req(((int32_t)(a1))<=((/*RF2*/(C)->_capacity/*i3p*/)),"new_count <= capacity");
fd.assertion_flag=1;
}
(ds.p=0x00E87708/*l2167c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E87908/*l2169c4\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(a1),"count = new_count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7copy(se_dump_stack*caller,T7* C,T0* a1){
T2 _c=0;
void**locals[2];
static se_frame_descriptor fd={"copy"" STRING",1,2,"%R7%other%R7%c%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E47804/*l1144c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_c;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A05D08/*l93c4\any.e*/);
ac_req(/* same_dynamic_type */
(((vc(((T0*)(C)),0))->id)==((vc(((T0*)(a1)),0))->id)),"same_dynamic_type(other)");
fd.assertion_flag=1;
}
(ds.p=0x00E47D08/*l1149c4\string.e*/);
_c=r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E47D12/*l1149c9\string.e*/))));
if(((ds.p=0x00E47E12/*l1150c9\string.e*/),((int32_t)(_c))>(/*IC*/(T2)(INT8_C(0))))){
if(((ds.p=0x00E47F22/*l1151c17\string.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))<(_c))){
(ds.p=0x00E4800C/*l1152c6\string.e*/);
/*SFN*/(C->_storage/*i3p*/)=new9(_c);
(ds.p=0x00E4810C/*l1153c6\string.e*/);
/*SFN*/(C->_capacity/*i3p*/)=_c;
}
(ds.p=0x00E4831A/*l1155c13\string.e*/);
r9copy_from(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E4832E/*l1155c23\string.e*/))))->_storage/*i3p*/),r2_ix_45(&ds,_c,/*IC*/(T2)(INT8_C(1))));
}
(ds.p=0x00E48508/*l1157c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=_c;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E48708/*l1159c4\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E48718/*l1159c12\string.e*/))))),"count = other.count");
(ds.p=0x01A06008/*l96c4\any.e*/);
ac_ens(r7is_equal(&ds,C,a1),"is_equal(other)");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T0* r7default(se_dump_stack*caller,T7* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"default"" STRING",1,1,"%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A07D12/*l125c9\any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7make(se_dump_stack*caller,T7* C,T2 a1){
void**locals[1];
static se_frame_descriptor fd={"make"" STRING",1,1,"%R7%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E04304/*l67c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0464E/*l70c39\string.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(0))),"non_negative_size");
fd.assertion_flag=1;
}
if(((ds.p=0x00E0482E/*l72c23\string.e*/),((int32_t)(a1))>(/*IC*/(T2)(INT8_C(0))))){
if(((ds.p=0x00E04922/*l73c17\string.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))<(a1))){
(ds.p=0x00E04A0C/*l74c6\string.e*/);
/*SFN*/(C->_storage/*i3p*/)=new9(a1);
(ds.p=0x00E04B0C/*l75c6\string.e*/);
/*SFN*/(C->_capacity/*i3p*/)=a1;
}
}
(ds.p=0x00E04E08/*l78c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=/*IC*/(T2)(INT8_C(0));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E05028/*l80c20\string.e*/);
ac_ens(((int32_t)(a1))<=((/*RF2*/(C)->_capacity/*i3p*/)),"needed_capacity <= capacity");
(ds.p=0x00E05124/*l81c18\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(INT8_C(0)),"empty_string");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7clear_count(se_dump_stack*caller,T7* C){
T2 o7_1124_15=0;
void**locals[1];
static se_frame_descriptor fd={"clear_count"" STRING",1,1,"%R7%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E45A04/*l1114c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&o7_1124_15;
set_dump_stack_top(&ds);/*link*/
o7_1124_15=(/*RF2*/(C)->_capacity/*i3p*/);
(ds.p=0x00E46108/*l1121c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=/*IC*/(T2)(INT8_C(0));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E4631C/*l1123c14\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(INT8_C(0)),"is_empty");
(ds.p=0x00E46408/*l1124c4\string.e*/);
ac_ens(((/*RF2*/(C)->_capacity/*i3p*/))==(o7_1124_15),"capacity = old capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T6 r7_ix_60(se_dump_stack*caller,T7* C,T0* a1){
T6 R=0;
T2 _i=0;
T2 _maxi=0;
void**locals[4];
static se_frame_descriptor fd={"infix ""<"" (""infix ""<"" STRING)",1,4,"%R7%other%R7%Result%E6%i%E2%maxi%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E09704/*l151c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_i;
locals[3]=(void**)&_maxi;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04401B24/*l27c18\comparable.e*/);
ac_req((a1)!=((void*)((void*)0)),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00E09F0A/*l159c5\string.e*/);
_i=/*IC*/(T2)(INT8_C(1));
(ds.p=0x00E0A00A/*l160c5\string.e*/);
_maxi=r2min(&ds,(/*RF2*/(C)->_count/*i3p*/),r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0A02E/*l160c23\string.e*/)))));
while (!(((ds.p=0x00E0A21C/*l162c14\string.e*/),(T6)((((int32_t)(_i))>(_maxi))||((T6)((r7item(&ds,C,_i))!=(r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0A242/*l162c33\string.e*/))),_i))))))))
{
(ds.p=0x00E0A40A/*l164c5\string.e*/);
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
if(((ds.p=0x00E0A612/*l166c9\string.e*/),((int32_t)(_i))<=(_maxi))){
(ds.p=0x00E0A70A/*l167c5\string.e*/);
R=((T6)(r3_ix_60(&ds,r7item(&ds,C,_i),r7item(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0A732/*l167c25\string.e*/))),_i))));
}
else{
(ds.p=0x00E0A90A/*l169c5\string.e*/);
R=((T6)(((int32_t)(_i))<=(r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0A928/*l169c20\string.e*/)))))));
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04401E2E/*l30c23\comparable.e*/);
ac_ens((T6)((!(R))||((T6)(r6_px_not(&ds,(T6)(r7_ix_60(&ds,se_i7(&ds,((T7*)ci(7,a1,0x04401E48/*l30c36\comparable.e*/))),(T0*)C)))))),"asymmetric");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7remove_last(se_dump_stack*caller,T7* C){
T2 o7_1549_12=0;
void**locals[1];
static se_frame_descriptor fd={"remove_last"" STRING",1,1,"%R7%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E60404/*l1540c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&o7_1549_12;
set_dump_stack_top(&ds);/*link*/
o7_1549_12=(/*RF2*/(C)->_count/*i3p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E60908/*l1545c4\string.e*/);
ac_req(r6_px_not(&ds,(T6)(r7is_empty(&ds,C))),"not is_empty");
fd.assertion_flag=1;
}
(ds.p=0x00E60B08/*l1547c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=r2_ix_45(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E60D08/*l1549c4\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(r2_ix_45(&ds,o7_1549_12,/*IC*/(T2)(INT8_C(1)))),"count = old count - 1");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T2 r7hash_code(se_dump_stack*caller,T7* C){
T2 R=0;
T2 _i=0;
T2 _j=0;
void**locals[3];
static se_frame_descriptor fd={"hash_code"" STRING",1,3,"%R7%Result%E2%i%E2%j%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E08404/*l132c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
locals[1]=(void**)&_i;
locals[2]=(void**)&_j;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E0890A/*l137c5\string.e*/);
_j=(/*RF2*/(C)->_count/*i3p*/);
(ds.p=0x00E08A0A/*l138c5\string.e*/);
_i=/*IC*/(T2)(INT8_C(1));
while (!(((ds.p=0x00E08C0E/*l140c7\string.e*/),((int32_t)(_j))<=(/*IC*/(T2)(INT8_C(0))))))
{
(ds.p=0x00E08E0A/*l142c5\string.e*/);
R=((int32_t)(((int32_t)(/*{INTEGER_32 5}*/INT32_C(5)))*(R)))+(/*IC*/(T2)(T3code(r7item(&ds,C,_i))));
(ds.p=0x00E08F0A/*l143c5\string.e*/);
_i=r2_ix_43(&ds,_i,/*IC*/(T2)(INT8_C(1)));
(ds.p=0x00E0900A/*l144c5\string.e*/);
_j=r2_ix_45(&ds,_j,/*IC*/(T2)(INT8_C(1)));
}
if(((ds.p=0x00E0921C/*l146c14\string.e*/),((int32_t)(R))<(/*IC*/(T2)(INT8_C(0))))){
(ds.p=0x00E0930A/*l147c5\string.e*/);
R=~(R);
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04601638/*l22c28\hashable.e*/);
ac_ens(((int32_t)(R))>=(/*IC*/(T2)(INT8_C(0))),"good_hash_value");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T0* r7twin(se_dump_stack*caller,T7* C){
T0* R=(void*)0;
void**locals[1];
static se_frame_descriptor fd={"twin"" STRING",1,1,"%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x01A04F12/*l79c9\any.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=((void*)new7());
r7copy(&ds,((T7*)R),((T0*)C));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x01A05524/*l85c18\any.e*/);
ac_ens(r7is_equal(&ds,se_i7(&ds,((T7*)ci(7,R,0x01A05516/*l85c11\any.e*/))),(T0*)C),"equal");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7add_last(se_dump_stack*caller,T7* C,T3 a1){
T2 o7_1417_16=0;
void**locals[2];
static se_frame_descriptor fd={"add_last"" STRING",1,2,"%R7%c%E3%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E57E04/*l1406c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o7_1417_16;
set_dump_stack_top(&ds);/*link*/
o7_1417_16=(/*RF2*/(C)->_count/*i3p*/);
if(((ds.p=0x00E5830E/*l1411c7\string.e*/),((/*RF2*/(C)->_count/*i3p*/))==((/*RF2*/(C)->_capacity/*i3p*/)))){
(ds.p=0x00E5840A/*l1412c5\string.e*/);
r7ensure_capacity(&ds,C,r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1))));
}
(ds.p=0x00E58618/*l1414c12\string.e*/);
((/*RF2*/(C)->_storage/*i3p*/))[(/*RF2*/(C)->_count/*i3p*/)]=(a1);
(ds.p=0x00E58708/*l1415c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E58908/*l1417c4\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(r2_ix_43(&ds,/*IC*/(T2)(INT8_C(1)),o7_1417_16)),"count = 1 + old count");
(ds.p=0x00E58A08/*l1418c4\string.e*/);
ac_ens((r7item(&ds,C,(/*RF2*/(C)->_count/*i3p*/)))==(a1),"item(count) = c");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7resize(se_dump_stack*caller,T7* C,T2 a1){
T2 o7_1111_16=0;
void**locals[2];
static se_frame_descriptor fd={"resize"" STRING",1,2,"%R7%new_count%E2%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E44704/*l1095c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&o7_1111_16;
set_dump_stack_top(&ds);/*link*/
o7_1111_16=(/*RF2*/(C)->_capacity/*i3p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E44C1C/*l1100c14\string.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(0))),"new_count >= 0");
fd.assertion_flag=1;
}
if(((ds.p=0x00E44E22/*l1102c17\string.e*/),((int32_t)(a1))<=((/*RF2*/(C)->_count/*i3p*/)))){
}
else if(((ds.p=0x00E44F28/*l1103c20\string.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))<(a1))){
(ds.p=0x00E4500A/*l1104c5\string.e*/);
r7ensure_capacity(&ds,C,a1);
}
else{
(ds.p=0x00E4521A/*l1106c13\string.e*/);
r9clear(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(C)->_count/*i3p*/),r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1))));
}
(ds.p=0x00E45408/*l1108c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=a1;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E45608/*l1110c4\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(a1),"count = new_count");
(ds.p=0x00E4571A/*l1111c13\string.e*/);
ac_ens(((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))>=(o7_1111_16),"capacity >= old capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/void r7ensure_capacity(se_dump_stack*caller,T7* C,T2 a1){
T2 _new_capacity=0;
void**locals[2];
static se_frame_descriptor fd={"ensure_capacity"" STRING",1,2,"%R7%needed_capacity%E2%new_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E87C04/*l2172c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_new_capacity;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E87E28/*l2174c20\string.e*/);
ac_req(((int32_t)(a1))>=(/*IC*/(T2)(INT8_C(0))),"needed_capacity >= 0");
fd.assertion_flag=1;
}
if(((ds.p=0x00E8821E/*l2178c15\string.e*/),r9is_null(&ds,(/*RF2*/(C)->_storage/*i3p*/)))){
(ds.p=0x00E8830A/*l2179c5\string.e*/);
_new_capacity=r2max(&ds,a1,/*IC*/(T2)(INT8_C(32)));
(ds.p=0x00E8840A/*l2180c5\string.e*/);
/*SFN*/(C->_storage/*i3p*/)=new9(_new_capacity);
(ds.p=0x00E8850A/*l2181c5\string.e*/);
/*SFN*/(C->_capacity/*i3p*/)=_new_capacity;
}
else if(((ds.p=0x00E88628/*l2182c20\string.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))<(a1))){
(ds.p=0x00E8870A/*l2183c5\string.e*/);
_new_capacity=r2max(&ds,a1,((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))*(/*IC*/(T2)(INT8_C(2))));
(ds.p=0x00E8880A/*l2184c5\string.e*/);
/*SFN*/(C->_storage/*i3p*/)=r9realloc(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(C)->_capacity/*i3p*/),_new_capacity);
(ds.p=0x00E8890A/*l2185c5\string.e*/);
/*SFN*/(C->_capacity/*i3p*/)=_new_capacity;
}
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E88C1A/*l2188c13\string.e*/);
ac_ens(((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))>=(a1),"capacity >= needed_capacity");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T6 r7same_as(se_dump_stack*caller,T7* C,T0* a1){
T6 R=0;
T9 _s1=(void*)0;
T9 _s2=(void*)0;
T2 _i=0;
void**locals[5];
static se_frame_descriptor fd={"same_as"" STRING",1,5,"%R7%other%R7%Result%E6%s1%E9%s2%E9%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E0D104/*l209c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
locals[2]=(void**)&_s1;
locals[3]=(void**)&_s2;
locals[4]=(void**)&_i;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E0D408/*l212c4\string.e*/);
ac_req((a1)!=((void*)((void*)0)),"other /= Void");
fd.assertion_flag=1;
}
(ds.p=0x00E0D808/*l216c4\string.e*/);
_i=(/*RF2*/(C)->_count/*i3p*/);
if(((ds.p=0x00E0D90E/*l217c7\string.e*/),(_i)==(r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E0D916/*l217c11\string.e*/))))))){
if(((ds.p=0x00E0DA20/*l218c16\string.e*/),r9fast_memcmp(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0DA38/*l218c28\string.e*/))))->_storage/*i3p*/),_i))){
(ds.p=0x00E0DB0C/*l219c6\string.e*/);
R=((T6)(1));
}
else{
(ds.p=0x00E0DE0E/*l222c7\string.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
(ds.p=0x00E0DF0E/*l223c7\string.e*/);
_s1=(/*RF2*/(C)->_storage/*i3p*/);
(ds.p=0x00E0E00E/*l224c7\string.e*/);
_s2=(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E0E01A/*l224c13\string.e*/))))->_storage/*i3p*/);
(ds.p=0x00E0E10E/*l225c7\string.e*/);
R=((T6)(1));
while (!(((ds.p=0x00E0E312/*l227c9\string.e*/),((int32_t)(_i))<(/*IC*/(T2)(INT8_C(0))))))
{
if(((ds.p=0x00E0E52A/*l229c21\string.e*/),r3same_as(&ds,(_s1)[_i],(_s2)[_i]))){
(ds.p=0x00E0E610/*l230c8\string.e*/);
_i=r2_ix_45(&ds,_i,/*IC*/(T2)(INT8_C(1)));
}
else{
(ds.p=0x00E0E810/*l232c8\string.e*/);
_i=/*IC*/(T2)(INT8_C(-1));
(ds.p=0x00E0E910/*l233c8\string.e*/);
R=((T6)(0));
}
}
}
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T8 r7to_external(se_dump_stack*caller,T7* C){
T8 R=(void*)0;
T2 o7_2031_12=0;
void**locals[2];
static se_frame_descriptor fd={"to_external"" STRING",1,2,"%R7%Result%E8%old value%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E7DE04/*l2014c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
locals[1]=(void**)&o7_2031_12;
set_dump_stack_top(&ds);/*link*/
o7_2031_12=(/*RF2*/(C)->_count/*i3p*/);
if(((ds.p=0x00E7E420/*l2020c16\string.e*/),((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))>((/*RF2*/(C)->_count/*i3p*/)))){
(ds.p=0x00E7E50A/*l2021c5\string.e*/);
/*SFN*/(C->_count/*i3p*/)=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
if(((ds.p=0x00E7E610/*l2022c8\string.e*/),(r7item(&ds,C,(/*RF2*/(C)->_count/*i3p*/)))!=(((T3)'\000')))){
(ds.p=0x00E7E70C/*l2023c6\string.e*/);
r7put(&ds,C,((T3)'\000'),(/*RF2*/(C)->_count/*i3p*/));
}
}
else{
(ds.p=0x00E7EA0A/*l2026c5\string.e*/);
r7add_last(&ds,C,((T3)'\000'));
}
(ds.p=0x00E7EC08/*l2028c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=r2_ix_45(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)));
(ds.p=0x00E7ED08/*l2029c4\string.e*/);
R=((void*)((/*RF2*/(C)->_storage/*i3p*/)));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E7EF08/*l2031c4\string.e*/);
ac_ens(((/*RF2*/(C)->_count/*i3p*/))==(o7_2031_12),"count = old count");
(ds.p=0x00E7F016/*l2032c11\string.e*/);
ac_ens((NULL!=R),"Result.is_not_null");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T2 r7count(se_dump_stack*caller,T7* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"count"" STRING",1,1,"%R7%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E02904/*l41c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
R=C->_count/*i3p*/;
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04003620/*l54c16\traversable.e*/);
ac_ens((R)==(r2_ix_43(&ds,r2_ix_45(&ds,r7upper(&ds,C),/*RF1lower*/INT32_C(1)),/*IC*/(T2)(INT8_C(1)))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T2 r7upper(se_dump_stack*caller,T7* C){
T2 R=0;
void**locals[1];
static se_frame_descriptor fd={"upper"" STRING",1,1,"%R7%Result%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E03704/*l55c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E03D08/*l61c4\string.e*/);
R=(/*RF2*/(C)->_count/*i3p*/);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E03F08/*l63c4\string.e*/);
ac_ens((R)==((/*RF2*/(C)->_count/*i3p*/)),"Result = count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T3 r7last(se_dump_stack*caller,T7* C){
T3 R=0;
void**locals[1];
static se_frame_descriptor fd={"last"" STRING",1,1,"%R7%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E6CE04/*l1742c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04005C08/*l92c4\traversable.e*/);
ac_req(r6_px_not(&ds,(T6)(r7is_empty(&ds,C))),"not is_empty");
fd.assertion_flag=1;
}
(ds.p=0x00E6D308/*l1747c4\string.e*/);
R=((/*RF2*/(C)->_storage/*i3p*/))[r2_ix_45(&ds,(/*RF2*/(C)->_count/*i3p*/),/*IC*/(T2)(INT8_C(1)))];
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04005F20/*l95c16\traversable.e*/);
ac_ens((R)==(r7item(&ds,C,r7upper(&ds,C))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T6 r7valid_index(se_dump_stack*caller,T7* C,T2 a1){
T6 R=0;
void**locals[2];
static se_frame_descriptor fd={"valid_index"" STRING",1,2,"%R7%i%E2%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x04002504/*l37c2\traversable.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x04002A08/*l42c4\traversable.e*/);
R=((T6)((T6)((((int32_t)(/*RF1lower*/INT32_C(1)))<=(a1))&&((T6)(((int32_t)(a1))<=(r7upper(&ds,C)))))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04002C20/*l44c16\traversable.e*/);
ac_ens((R)==(r6_ix_and(&ds,(T6)(((int32_t)(/*RF1lower*/INT32_C(1)))<=(a1)),(T6)(((int32_t)(a1))<=(r7upper(&ds,C))))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T6 r7is_empty(se_dump_stack*caller,T7* C){
T6 R=0;
void**locals[1];
static se_frame_descriptor fd={"is_empty"" STRING",1,1,"%R7%Result%E6%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E06804/*l104c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
(ds.p=0x00E06D08/*l109c4\string.e*/);
R=((T6)(((/*RF2*/(C)->_count/*i3p*/))==(INT8_C(0))));
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04003F20/*l63c16\traversable.e*/);
ac_ens((R)==(((/*RF2*/(C)->_count/*i3p*/))==(INT8_C(0))),"definition");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/T3 r7item(se_dump_stack*caller,T7* C,T2 a1){
T3 R=0;
void**locals[2];
static se_frame_descriptor fd={"item"" STRING",1,2,"%R7%i%E2%Result%E3%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E07004/*l112c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x04004808/*l72c4\traversable.e*/);
ac_req(r7valid_index(&ds,C,a1),"valid_index(i)");
fd.assertion_flag=1;
}
(ds.p=0x00E07508/*l117c4\string.e*/);
R=((/*RF2*/(C)->_storage/*i3p*/))[r2_ix_45(&ds,a1,/*IC*/(T2)(INT8_C(1)))];
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7put(se_dump_stack*caller,T7* C,T3 a1,T2 a2){
void**locals[2];
static se_frame_descriptor fd={"put"" STRING",1,2,"%R7%c%E3%i%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E51404/*l1300c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&a2;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E51922/*l1305c17\string.e*/);
ac_req(r7valid_index(&ds,C,a2),"valid_index");
fd.assertion_flag=1;
}
(ds.p=0x00E51B18/*l1307c12\string.e*/);
((/*RF2*/(C)->_storage/*i3p*/))[r2_ix_45(&ds,a2,/*IC*/(T2)(INT8_C(1)))]=(a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E51D08/*l1309c4\string.e*/);
ac_ens((r7item(&ds,C,a2))==(a1),"item(i) = c");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/

/*STRING*/T0* r7_ix_43(se_dump_stack*caller,T7* C,T0* a1){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
T0* R=(void*)0;
void**locals[2];
static se_frame_descriptor fd={"infix ""+"" (""infix ""+"" STRING)",1,2,"%R7%other%R7%Result%R7%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E50504/*l1285c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&R;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E50B24/*l1291c18\string.e*/);
ac_req((a1)!=((void*)((void*)0)),"other_exists");
fd.assertion_flag=1;
}
(ds.p=0x00E50D08/*l1293c4\string.e*/);
tmp0=((T0*)(new7()));
r7make(&ds,((T7*)tmp0),r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E50D3E/*l1293c31\string.e*/))))));
R=tmp0;
se_i7(&ds,((T7*)(R)));(ds.p=0x00E50E16/*l1294c11\string.e*/);
r7append(&ds,se_i7(&ds,((T7*)ci(7,R,0x00E50E08/*l1294c4\string.e*/))),(T0*)C);
(ds.p=0x00E50F16/*l1295c11\string.e*/);
r7append(&ds,se_i7(&ds,((T7*)ci(7,R,0x00E50F08/*l1295c4\string.e*/))),a1);
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E51132/*l1297c25\string.e*/);
ac_ens((r7count(&ds,se_i7(&ds,((T7*)ci(7,R,0x00E51124/*l1297c18\string.e*/)))))==(r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E51152/*l1297c41\string.e*/)))))),"result_count");
fd.assertion_flag=1;
}
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
return R;
}/*--*/

/*STRING*/void r7append(se_dump_stack*caller,T7* C,T0* a1){
T2 _s_count=0;
T2 _needed_capacity=0;
void**locals[3];
static se_frame_descriptor fd={"append"" STRING",1,3,"%R7%s%R7%s_count%E2%needed_capacity%E2%",1};
se_dump_stack ds;
ds.fd=&fd;
ds.current=(void*)&C;
ds.p=0x00E49B04/*l1179c2\string.e*/;
ds.caller=caller;
ds.locals=locals;
ds.exception_origin=NULL;
locals[0]=(void**)&a1;
locals[1]=(void**)&_s_count;
locals[2]=(void**)&_needed_capacity;
set_dump_stack_top(&ds);/*link*/
if(fd.assertion_flag){
fd.assertion_flag=0;
(ds.p=0x00E4A020/*l1184c16\string.e*/);
ac_req((a1)!=((void*)((void*)0)),"s_not_void");
fd.assertion_flag=1;
}
(ds.p=0x00E4A408/*l1188c4\string.e*/);
_s_count=r7count(&ds,se_i7(&ds,((T7*)ci(7,a1,0x00E4A41E/*l1188c15\string.e*/))));
(ds.p=0x00E4A508/*l1189c4\string.e*/);
_needed_capacity=r2_ix_43(&ds,(/*RF2*/(C)->_count/*i3p*/),_s_count);
if(((ds.p=0x00E4A62E/*l1190c23\string.e*/),((int32_t)(_needed_capacity))>((/*RF2*/(C)->_capacity/*i3p*/)))){
(ds.p=0x00E4A70A/*l1191c5\string.e*/);
r7ensure_capacity(&ds,C,_needed_capacity);
}
(ds.p=0x00E4A918/*l1193c12\string.e*/);
r9copy_at(&ds,(/*RF2*/(C)->_storage/*i3p*/),(/*RF2*/(C)->_count/*i3p*/),(/*RF2*/(se_i7(&ds,((T7*)ci(7,a1,0x00E4A936/*l1193c27\string.e*/))))->_storage/*i3p*/),_s_count);
(ds.p=0x00E4AA08/*l1194c4\string.e*/);
/*SFN*/(C->_count/*i3p*/)=_needed_capacity;
if(se_rci(caller,C))se_i7(&ds,C);
set_dump_stack_top(caller);/*unlink*/
}/*--*/
se_frame_descriptor se_ifd7={"invariant STRING",1,0,"%R7%",1};

T7*se_i7(se_dump_stack*caller,T7*C){
se_dump_stack ds;
ds.fd=&se_ifd7;
ds.current=((void*)&C);
ds.p=0x00E8AD02/*l2221c1\string.e*/;
ds.caller=caller;
ds.exception_origin=NULL;
ds.locals=NULL;
se_dst=&ds;/*link*/
if(ds.fd->assertion_flag){
ds.fd->assertion_flag=0;
(ds.p=0x00E8AE08/*l2222c4\string.e*/);
ac_inv(((int32_t)(/*IC*/(T2)(INT8_C(0))))<=((/*RF2*/(C)->_count/*i3p*/)),"0 <= count");
(ds.p=0x00E8AF10/*l2223c8\string.e*/);
ac_inv(((int32_t)((/*RF2*/(C)->_count/*i3p*/)))<=((/*RF2*/(C)->_capacity/*i3p*/)),"count <= capacity");
(ds.p=0x00E8B01E/*l2224c15\string.e*/);
ac_inv((T6)((!(((int32_t)((/*RF2*/(C)->_capacity/*i3p*/)))>(/*IC*/(T2)(INT8_C(0)))))||((T6)(r9is_not_null(&ds,(/*RF2*/(C)->_storage/*i3p*/))))),"capacity > 0 implies storage.is_not_null");
ds.fd->assertion_flag=1;
}
se_dst=caller;/*unlink*/
return C;
}/*--*/

T0*se_ms(int c,char*e){
/* Allocate a Manifest STRING.*/
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

T0*se_string(char*e){
/* Allocate an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=new7();
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)new9(c+1));
memcpy(s->_storage,e,c+1);
return((T0*)s);}/*--*/

void manifest_string_mark1(void){
}/*--*/

void once_function_mark(void){
/*NON_VOID_NO_DISPATCH:*/
/*Ordinary once functions:*/
if(NULL!=oBC13io)gc_mark40((T40*)(oBC13io));
if(NULL!=oBC13std_output)gc_mark47((T47*)(oBC13std_output));
if(NULL!=oBC13std_input)gc_mark48((T48*)(oBC13std_input));
if(NULL!=oBC44last_string)gc_mark7((T7*)(oBC44last_string));
}/*--*/

void gc_start(void){
if(gc_is_off)return;
if(garbage_delayed())return;
handle(SE_HANDLE_ENTER_GC,NULL);
gcmt_tail_addr=(((char*)(gcmt[gcmt_used-1]))+(gcmt[gcmt_used-1])->size);
((gc25*)eiffel_root_object)->header.flag=FSOH_UNMARKED;
if(na_env123.store_left>0){
na_env123.store->header.size=na_env123.store_left;
na_env123.store->header.magic_flag=RSOH_FREE;
na_env123.store_left=0;
}
na_env123.chunk_list=NULL;
na_env123.store_chunk=NULL;
gc_free48=(void*)0;
gc_free47=(void*)0;
gc_free61=(void*)0;
gc_free122=(void*)0;
gc_free40=(void*)0;
gc_free25=(void*)0;
if(na_env9.store_left>0){
na_env9.store->header.size=na_env9.store_left;
na_env9.store->header.magic_flag=RSOH_FREE;
na_env9.store_left=0;
}
na_env9.chunk_list=NULL;
na_env9.store_chunk=NULL;
gc_free7=(void*)0;
gc_mark25(eiffel_root_object);
manifest_string_mark1();
once_function_mark();
{int i=SE_MAXID-1;
while(i>=0){
if(g[i]!=NULL)gc_mark7(g[i]);
i--;}
}
{int i=SE_MAXID-1;
while(i>=0){
if(t[i]!=NULL)gc_mark7(t[i]);
i--;}
}
mark_stack_and_registers();
gc_sweep();
collector_counter++;
handle(SE_HANDLE_EXIT_GC,NULL);
}/*--*/
na_env na_env123={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark123};
gc48*store48=(void*)0;
int store_left48=0;
fsoc*store_chunk48=(void*)0;
gc48*gc_free48=(void*)0;
gc47*store47=(void*)0;
int store_left47=0;
fsoc*store_chunk47=(void*)0;
gc47*gc_free47=(void*)0;
gc61*store61=(void*)0;
int store_left61=0;
fsoc*store_chunk61=(void*)0;
gc61*gc_free61=(void*)0;
gc122*store122=(void*)0;
int store_left122=0;
fsoc*store_chunk122=(void*)0;
gc122*gc_free122=(void*)0;
gc40*store40=(void*)0;
int store_left40=0;
fsoc*store_chunk40=(void*)0;
gc40*gc_free40=(void*)0;
gc25*store25=(void*)0;
int store_left25=0;
fsoc*store_chunk25=(void*)0;
gc25*gc_free25=(void*)0;
na_env na_env9={0,NULL,NULL,NULL,(void(*)(T0*))gc_mark9};
gc7*store7=(void*)0;
int store_left7=0;
fsoc*store_chunk7=(void*)0;
gc7*gc_free7=(void*)0;

void gc_mark123(T123 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
{rsoh*h=((rsoh*)o)-1;
 if((h->header.magic_flag)==RSOH_UNMARKED){
    h->header.magic_flag=RSOH_MARKED;
    {T0* e;
T0**p=((void*)(o+((((h->header.size)-sizeof(rsoh))/sizeof(e))-1)));
for(;((void*)p)>=((void*)o);p--){
e=*p;
if(NULL!=e)gc_mark7((T7*)(e));
}}}}
}/*--*/

T123 new123(unsigned int size){
size=(size*sizeof(T0*))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env123.store_left)){
rsoh*r=na_env123.store;
na_env123.store_left-=size;
if(na_env123.store_left>sizeof(rsoh)){
r->header.size=size;
na_env123.store=((rsoh*)(((char*)(na_env123.store))+size));
}
else {
r->header.size=size+na_env123.store_left;
na_env123.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T123)(r+1));
}
return((T123)new_na(&na_env123,size));
}/*--*/

void gc_sweep48(fsoc*c){
gc48*o1,*o2;
o1=((gc48*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store48;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free48;
gc_free48=o1;
}
}
}
else{
int dead=1;
gc48* old_gc_free = gc_free48;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free48;
gc_free48=o1;
}
}
if (dead){
gc_free48 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark48(T48*o){
se_gc_check_id(o,48);
{
if(((gc48*)o)->header.flag==FSOH_UNMARKED){
((gc48*)o)->header.flag=FSOH_MARKED;
/*i2p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
}
}
}/*--*/

void gc_align_mark48(fsoc*c,gc48*p){
gc48*b=((gc48*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store48)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T48*o=(&(p->object));
((gc48*)o)->header.flag=FSOH_MARKED;
/*i2p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
}
}
}/*--*/
fsoc H48={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark48,
(void(*)(mch*))gc_sweep48},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc48))-1)};

T48*new48(void){
gc48*n;
fsoc*c;
if(store_left48>1){
store_left48--;
n=store48++;
}
else if(gc_free48!=NULL){
n=gc_free48;
gc_free48=n->header.next;
}
else if(store_left48==1){
store_left48=0;
store_chunk48->header.state_type=FSO_USED_CHUNK;
n=store48++;
}
else{
c=gc_fsoc_get1();
if(gc_free48!=NULL){
n=gc_free48;
gc_free48=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk48=c;
*store_chunk48=H48;
store48=((gc48*)(&(store_chunk48->first_object)));
store_left48=H48.count_minus_one;
n=store48++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M48;
return((T48*)n);
}/*--*/

void gc_sweep47(fsoc*c){
gc47*o1,*o2;
o1=((gc47*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store47;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free47;
gc_free47=o1;
}
}
}
else{
int dead=1;
gc47* old_gc_free = gc_free47;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free47;
gc_free47=o1;
}
}
if (dead){
gc_free47 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark47(T47*o){
se_gc_check_id(o,47);
{
if(((gc47*)o)->header.flag==FSOH_UNMARKED){
((gc47*)o)->header.flag=FSOH_MARKED;
/*i4p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
/*i4p*/}
}
}/*--*/

void gc_align_mark47(fsoc*c,gc47*p){
gc47*b=((gc47*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store47)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T47*o=(&(p->object));
((gc47*)o)->header.flag=FSOH_MARKED;
/*i4p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
/*i4p*/}
}
}/*--*/
fsoc H47={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark47,
(void(*)(mch*))gc_sweep47},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc47))-1)};

T47*new47(void){
gc47*n;
fsoc*c;
if(store_left47>1){
store_left47--;
n=store47++;
}
else if(gc_free47!=NULL){
n=gc_free47;
gc_free47=n->header.next;
}
else if(store_left47==1){
store_left47=0;
store_chunk47->header.state_type=FSO_USED_CHUNK;
n=store47++;
}
else{
c=gc_fsoc_get1();
if(gc_free47!=NULL){
n=gc_free47;
gc_free47=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk47=c;
*store_chunk47=H47;
store47=((gc47*)(&(store_chunk47->first_object)));
store_left47=H47.count_minus_one;
n=store47++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M47;
return((T47*)n);
}/*--*/

void gc_sweep61(fsoc*c){
gc61*o1,*o2;
o1=((gc61*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store61;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free61;
gc_free61=o1;
}
}
}
else{
int dead=1;
gc61* old_gc_free = gc_free61;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free61;
gc_free61=o1;
}
}
if (dead){
gc_free61 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark61(T61*o){
se_gc_check_id(o,61);
{
if(((gc61*)o)->header.flag==FSOH_UNMARKED){
((gc61*)o)->header.flag=FSOH_MARKED;
/*i10p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
/*i10p*/if(NULL!=o->_path)gc_mark7((T7*)(o->_path));
}
}
}/*--*/

void gc_align_mark61(fsoc*c,gc61*p){
gc61*b=((gc61*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store61)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T61*o=(&(p->object));
((gc61*)o)->header.flag=FSOH_MARKED;
/*i10p*/if(NULL!=o->_buffer)gc_mark9((o->_buffer));
/*i10p*/if(NULL!=o->_path)gc_mark7((T7*)(o->_path));
}
}
}/*--*/
fsoc H61={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark61,
(void(*)(mch*))gc_sweep61},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc61))-1)};

T61*new61(void){
gc61*n;
fsoc*c;
if(store_left61>1){
store_left61--;
n=store61++;
}
else if(gc_free61!=NULL){
n=gc_free61;
gc_free61=n->header.next;
}
else if(store_left61==1){
store_left61=0;
store_chunk61->header.state_type=FSO_USED_CHUNK;
n=store61++;
}
else{
c=gc_fsoc_get1();
if(gc_free61!=NULL){
n=gc_free61;
gc_free61=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk61=c;
*store_chunk61=H61;
store61=((gc61*)(&(store_chunk61->first_object)));
store_left61=H61.count_minus_one;
n=store61++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M61;
return((T61*)n);
}/*--*/

void gc_sweep122(fsoc*c){
gc122*o1,*o2;
o1=((gc122*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store122;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free122;
gc_free122=o1;
}
}
}
else{
int dead=1;
gc122* old_gc_free = gc_free122;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free122;
gc_free122=o1;
}
}
if (dead){
gc_free122 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark122(T122*o){
se_gc_check_id(o,122);
{
if(((gc122*)o)->header.flag==FSOH_UNMARKED){
((gc122*)o)->header.flag=FSOH_MARKED;
/*i4p*/{
T123 na=o->_storage;
if(gc_find_chunk(na)!=NULL){/* non external NA */
   rsoh*h=((rsoh*)na)-1;
   if((h->header.magic_flag)==RSOH_UNMARKED){
      h->header.magic_flag=RSOH_MARKED;
r122mark_native_arrays(NULL,o);
}
}
}}
}
}/*--*/

void gc_align_mark122(fsoc*c,gc122*p){
gc122*b=((gc122*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store122)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T122*o=(&(p->object));
((gc122*)o)->header.flag=FSOH_MARKED;
/*i4p*/{
T123 na=o->_storage;
if(gc_find_chunk(na)!=NULL){/* non external NA */
   rsoh*h=((rsoh*)na)-1;
   if((h->header.magic_flag)==RSOH_UNMARKED){
      h->header.magic_flag=RSOH_MARKED;
r122mark_native_arrays(NULL,o);
}
}
}}
}
}/*--*/
fsoc H122={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark122,
(void(*)(mch*))gc_sweep122},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc122))-1)};

T122*new122(void){
gc122*n;
fsoc*c;
if(store_left122>1){
store_left122--;
n=store122++;
}
else if(gc_free122!=NULL){
n=gc_free122;
gc_free122=n->header.next;
}
else if(store_left122==1){
store_left122=0;
store_chunk122->header.state_type=FSO_USED_CHUNK;
n=store122++;
}
else{
c=gc_fsoc_get1();
if(gc_free122!=NULL){
n=gc_free122;
gc_free122=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk122=c;
*store_chunk122=H122;
store122=((gc122*)(&(store_chunk122->first_object)));
store_left122=H122.count_minus_one;
n=store122++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M122;
return((T122*)n);
}/*--*/

void gc_sweep40(fsoc*c){
gc40*o1,*o2;
o1=((gc40*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store40;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free40;
gc_free40=o1;
}
}
}
else{
int dead=1;
gc40* old_gc_free = gc_free40;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free40;
gc_free40=o1;
}
}
if (dead){
gc_free40 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark40(T40*o){
se_gc_check_id(o,40);
{
if(((gc40*)o)->header.flag==FSOH_UNMARKED){
((gc40*)o)->header.flag=FSOH_MARKED;
/*i3p*/}
}
}/*--*/

void gc_align_mark40(fsoc*c,gc40*p){
gc40*b=((gc40*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store40)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T40*o=(&(p->object));
((gc40*)o)->header.flag=FSOH_MARKED;
/*i3p*/}
}
}/*--*/
fsoc H40={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark40,
(void(*)(mch*))gc_sweep40},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc40))-1)};

T40*new40(void){
gc40*n;
fsoc*c;
if(store_left40>1){
store_left40--;
n=store40++;
}
else if(gc_free40!=NULL){
n=gc_free40;
gc_free40=n->header.next;
}
else if(store_left40==1){
store_left40=0;
store_chunk40->header.state_type=FSO_USED_CHUNK;
n=store40++;
}
else{
c=gc_fsoc_get1();
if(gc_free40!=NULL){
n=gc_free40;
gc_free40=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk40=c;
*store_chunk40=H40;
store40=((gc40*)(&(store_chunk40->first_object)));
store_left40=H40.count_minus_one;
n=store40++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M40;
return((T40*)n);
}/*--*/

void gc_sweep25(fsoc*c){
gc25*o1,*o2;
o1=((gc25*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store25;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free25;
gc_free25=o1;
}
}
}
else{
int dead=1;
gc25* old_gc_free = gc_free25;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free25;
gc_free25=o1;
}
}
if (dead){
gc_free25 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark25(T25*o){
se_gc_check_id(o,25);
{
((gc25*)o)->header.flag=FSOH_MARKED;
}
}/*--*/

void gc_align_mark25(fsoc*c,gc25*p){
gc25*b=((gc25*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store25)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T25*o=(&(p->object));
((gc25*)o)->header.flag=FSOH_MARKED;
}
}
}/*--*/
fsoc H25={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark25,
(void(*)(mch*))gc_sweep25},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc25))-1)};

T25*new25(void){
gc25*n;
fsoc*c;
if(store_left25>1){
store_left25--;
n=store25++;
}
else if(gc_free25!=NULL){
n=gc_free25;
gc_free25=n->header.next;
}
else if(store_left25==1){
store_left25=0;
store_chunk25->header.state_type=FSO_USED_CHUNK;
n=store25++;
}
else{
c=gc_fsoc_get1();
if(gc_free25!=NULL){
n=gc_free25;
gc_free25=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk25=c;
*store_chunk25=H25;
store25=((gc25*)(&(store_chunk25->first_object)));
store_left25=H25.count_minus_one;
n=store25++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M25;
return((T25*)n);
}/*--*/

void gc_mark9(T9 o){
if(NULL==gc_find_chunk(o))
return; /* external NA */
(((rsoh*)o)-1)->header.magic_flag=RSOH_MARKED;
}/*--*/

T9 new9(unsigned int size){
size=(size*sizeof(T3))+sizeof(rsoh);
size=((size+(sizeof(double)-1))&~(sizeof(double)-1));
if (size<=(na_env9.store_left)){
rsoh*r=na_env9.store;
na_env9.store_left-=size;
if(na_env9.store_left>sizeof(rsoh)){
r->header.size=size;
na_env9.store=((rsoh*)(((char*)(na_env9.store))+size));
}
else {
r->header.size=size+na_env9.store_left;
na_env9.store_left=0;
}
(r->header.magic_flag)=RSOH_UNMARKED;
((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
return((T9)(r+1));
}
return((T9)new_na(&na_env9,size));
}/*--*/

void gc_sweep7(fsoc*c){
gc7*o1,*o2;
o1=((gc7*)(&(c->first_object)));
if(c->header.state_type==FSO_STORE_CHUNK){
for(;o1<store7;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
}
else{
int dead=1;
gc7* old_gc_free = gc_free7;
o2=o1+c->count_minus_one;
for(;o1<=o2;o1++){
if((o1->header.flag)==FSOH_MARKED){
o1->header.flag=FSOH_UNMARKED;
dead=0;}
else{
o1->header.next=gc_free7;
gc_free7=o1;
}
}
if (dead){
gc_free7 = old_gc_free;
c->next=fsocfl;
fsocfl=c;
c->header.state_type=FSO_FREE_CHUNK;
}
}
}/*--*/

void gc_mark7(T7*o){
se_gc_check_id(o,7);
{
if(((gc7*)o)->header.flag==FSOH_UNMARKED){
((gc7*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_storage)gc_mark9((o->_storage));
}
}
}/*--*/

void gc_align_mark7(fsoc*c,gc7*p){
gc7*b=((gc7*)(&(c->first_object)));
if((c->header.state_type==FSO_STORE_CHUNK)&&(((char*)p)>=((char*)store7)))return;
if(((char*)p)>((char*)(b+(c->count_minus_one))))return;
if(((char*)p)<((char*)b))return;
if(((((char*)p)-((char*)b))%sizeof(*p))==0){
if(p->header.flag==FSOH_UNMARKED){
T7*o=(&(p->object));
((gc7*)o)->header.flag=FSOH_MARKED;
/*i3p*/if(NULL!=o->_storage)gc_mark9((o->_storage));
}
}
}/*--*/
fsoc H7={{FSOC_SIZE,FSO_STORE_CHUNK,
(void(*)(mch*,void*))gc_align_mark7,
(void(*)(mch*))gc_sweep7},NULL,(((FSOC_SIZE-sizeof(fsoc)+sizeof(double))/sizeof(gc7))-1)};

T7*new7(void){
gc7*n;
fsoc*c;
if(store_left7>1){
store_left7--;
n=store7++;
}
else if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else if(store_left7==1){
store_left7=0;
store_chunk7->header.state_type=FSO_USED_CHUNK;
n=store7++;
}
else{
c=gc_fsoc_get1();
if(gc_free7!=NULL){
n=gc_free7;
gc_free7=n->header.next;
}
else{
if(c==NULL)c=gc_fsoc_get2();
store_chunk7=c;
*store_chunk7=H7;
store7=((gc7*)(&(store_chunk7->first_object)));
store_left7=H7.count_minus_one;
n=store7++;
}
}
n->header.flag=FSOH_UNMARKED;
n->object=M7;
return((T7*)n);
}/*--*/
T25*eiffel_root_object=(void*)0;
int se_argc;
char**se_argv;
T7*g[124];
T7*t[124];
char*p[124];
void(*se_prinT[124])(FILE*,void*);
int se_strucT[124]={0,sizeof(T1),sizeof(T2),sizeof(T3),0,0,sizeof(T6),sizeof(T7),sizeof(T8),sizeof(T9),sizeof(T10),0,0,0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T25),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T40),
0,
0,
0,
0,
0,
0,
sizeof(T47),
sizeof(T48),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T61),
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
sizeof(T122),
sizeof(T123)};

void se_atexit(void){
se_frame_descriptor fd={"<atexit wrapper>",0,0,"",1};
se_dump_stack ds;
ds.fd=&fd;
ds.p=0;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
r47se_atexit(&ds,NULL/*Unused Target*/);
}/*--*/

void initialize_eiffel_runtime(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_frame_descriptor irfd={"<runtime init>",0,0,"",1};
se_dump_stack ds = {NULL,NULL,0,NULL,NULL};
ds.fd=&irfd;
set_dump_stack_top(&ds);/*link*/
se_argc=argc;
se_argv=argv;
atexit(se_atexit);
gcmt=((mch**)se_malloc((gcmt_max+1)*sizeof(void*)));
#ifdef FIXED_STACK_BOTTOM
if (!stack_bottom) stack_bottom=((void**)(void*)(&argc));
#endif
p[0]="???";
p[25]="C:\\Users\\SEB\\Documents\\GitHub\\GLOEiffelProject\\interface.e";
p[100]="C:\\SmartEiffel\\lib\\kernel\\procedure.e";
p[94]="C:\\SmartEiffel\\lib\\kernel\\memory.e";
p[15]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[16]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[68]="C:\\SmartEiffel\\lib\\kernel\\routine.e";
p[17]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[18]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[19]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[20]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[21]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[22]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[23]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[14]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[24]="C:\\SmartEiffel\\lib\\kernel\\tuple.e";
p[8]="C:\\SmartEiffel\\lib\\kernel\\pointer.e";
p[99]="C:\\SmartEiffel\\lib\\kernel\\reference.e";
p[67]="C:\\SmartEiffel\\lib\\kernel\\function.e";
p[6]="C:\\SmartEiffel\\lib\\kernel\\boolean.e";
p[55]="C:\\SmartEiffel\\lib\\kernel\\safe_equal.e";
p[13]="C:\\SmartEiffel\\lib\\kernel\\any.e";
p[101]="C:\\SmartEiffel\\lib\\kernel\\weak_reference.e";
p[36]="C:\\SmartEiffel\\lib\\kernel\\platform.e";
p[73]="C:\\SmartEiffel\\lib\\kernel\\internal\\internals_handler.e";
p[85]="C:\\SmartEiffel\\lib\\kernel\\internal\\native_array_internals.e";
p[45]="C:\\SmartEiffel\\lib\\kernel\\internal\\typed_internals.e";
p[51]="C:\\SmartEiffel\\lib\\kernel\\internal\\native_array_collector.e";
p[46]="C:\\SmartEiffel\\lib\\kernel\\internal\\internals.e";
p[50]="C:\\SmartEiffel\\lib\\storage\\collection.e";
p[81]="C:\\SmartEiffel\\lib\\storage\\collection\\fast_array.e";
p[49]="C:\\SmartEiffel\\lib\\storage\\collection\\array.e";
p[102]="C:\\SmartEiffel\\lib\\storage\\collection\\ring_array.e";
p[54]="C:\\SmartEiffel\\lib\\storage\\low_level\\native_array.e";
p[93]="C:\\SmartEiffel\\lib\\storage\\low_level\\recycling_pool.e";
p[52]="C:\\SmartEiffel\\lib\\storage\\internal\\arrayed_collection.e";
p[106]="C:\\SmartEiffel\\lib\\io\\directory_notation.e";
p[53]="C:\\SmartEiffel\\lib\\io\\filter.e";
p[26]="C:\\SmartEiffel\\lib\\io\\output_stream.e";
p[113]="C:\\SmartEiffel\\lib\\io\\path_name.e";
p[71]="C:\\SmartEiffel\\lib\\io\\filter_input_stream.e";
p[38]="C:\\SmartEiffel\\lib\\io\\terminal_output_stream.e";
p[104]="C:\\SmartEiffel\\lib\\io\\file_tools.e";
p[42]="C:\\SmartEiffel\\lib\\io\\terminal_input_stream.e";
p[41]="C:\\SmartEiffel\\lib\\io\\terminal_input_output_stream.e";
p[63]="C:\\SmartEiffel\\lib\\io\\filter_output_stream.e";
p[43]="C:\\SmartEiffel\\lib\\io\\input_stream.e";
p[27]="C:\\SmartEiffel\\lib\\io\\stream.e";
p[62]="C:\\SmartEiffel\\lib\\io\\terminal\\file.e";
p[61]="C:\\SmartEiffel\\lib\\io\\terminal\\text_file_read.e";
p[40]="C:\\SmartEiffel\\lib\\io\\terminal\\std_input_output.e";
p[37]="C:\\SmartEiffel\\lib\\io\\terminal\\std_error.e";
p[48]="C:\\SmartEiffel\\lib\\io\\terminal\\std_input.e";
p[47]="C:\\SmartEiffel\\lib\\io\\terminal\\std_output.e";
p[44]="C:\\SmartEiffel\\lib\\io\\low_level\\input_stream_tools.e";
p[30]="C:\\SmartEiffel\\lib\\io\\low_level\\output_stream_tools.e";
p[39]="C:\\SmartEiffel\\lib\\io\\low_level\\redirection_tools.e";
p[105]="C:\\SmartEiffel\\lib\\io\\low_level\\basic_directory.e";
p[115]="C:\\SmartEiffel\\lib\\io\\internal\\unixish_path_name.e";
p[29]="C:\\SmartEiffel\\lib\\io\\internal\\filterable.e";
p[112]="C:\\SmartEiffel\\lib\\io\\internal\\path_joiner.e";
p[114]="C:\\SmartEiffel\\lib\\io\\path_name\\posix_path_name.e";
p[111]="C:\\SmartEiffel\\lib\\io\\path_name\\path_name_notation.e";
p[109]="C:\\SmartEiffel\\lib\\io\\path_name\\macintosh_directory_notation.e";
p[117]="C:\\SmartEiffel\\lib\\io\\path_name\\openvms_directory_notation.e";
p[120]="C:\\SmartEiffel\\lib\\io\\path_name\\microsoft_path_name.e";
p[119]="C:\\SmartEiffel\\lib\\io\\path_name\\windows_directory_notation.e";
p[110]="C:\\SmartEiffel\\lib\\io\\path_name\\unix_directory_notation.e";
p[118]="C:\\SmartEiffel\\lib\\io\\path_name\\amiga_directory_notation.e";
p[121]="C:\\SmartEiffel\\lib\\io\\path_name\\cygwin_directory_notation.e";
p[107]="C:\\SmartEiffel\\lib\\unicode\\unicode_string_handler.e";
p[66]="C:\\SmartEiffel\\lib\\iterator\\iterator.e";
p[74]="C:\\SmartEiffel\\lib\\iterator\\internal\\iterator_on_traversable.e";
p[82]="C:\\SmartEiffel\\lib\\iterator\\internal\\iterator_on_unicode_string.e";
p[70]="C:\\SmartEiffel\\lib\\iterator\\internal\\iterator_on_string.e";
p[84]="C:\\SmartEiffel\\lib\\misc\\mini_parser_buffer.e";
p[83]="C:\\SmartEiffel\\lib\\sequencer\\events_set.e";
p[64]="C:\\SmartEiffel\\lib\\sequencer\\event_descriptor.e";
p[72]="C:\\SmartEiffel\\lib\\sequencer\\events\\can_read_data_from_stream.e";
p[98]="C:\\SmartEiffel\\lib\\sequencer\\events\\network_connection_occurred.e";
p[65]="C:\\SmartEiffel\\lib\\sequencer\\events\\can_write_data_to_stream.e";
p[28]="C:\\SmartEiffel\\lib\\abilities\\recyclable.e";
p[92]="C:\\SmartEiffel\\lib\\abilities\\disposable.e";
p[32]="C:\\SmartEiffel\\lib\\abilities\\traversable.e";
p[35]="C:\\SmartEiffel\\lib\\abilities\\hashable.e";
p[33]="C:\\SmartEiffel\\lib\\abilities\\storable.e";
p[34]="C:\\SmartEiffel\\lib\\abilities\\comparable.e";
p[12]="C:\\SmartEiffel\\lib\\numeric\\real_extended.e";
p[58]="C:\\SmartEiffel\\lib\\numeric\\real_general.e";
p[2]="C:\\SmartEiffel\\lib\\numeric\\integer_32.e";
p[59]="C:\\SmartEiffel\\lib\\numeric\\number.e";
p[4]="C:\\SmartEiffel\\lib\\numeric\\real_32.e";
p[1]="C:\\SmartEiffel\\lib\\numeric\\integer_8.e";
p[77]="C:\\SmartEiffel\\lib\\numeric\\mutable_big_integer.e";
p[11]="C:\\SmartEiffel\\lib\\numeric\\integer_64.e";
p[69]="C:\\SmartEiffel\\lib\\numeric\\number_tools.e";
p[56]="C:\\SmartEiffel\\lib\\numeric\\integer_general.e";
p[5]="C:\\SmartEiffel\\lib\\numeric\\real_64.e";
p[57]="C:\\SmartEiffel\\lib\\numeric\\numeric.e";
p[10]="C:\\SmartEiffel\\lib\\numeric\\integer_16.e";
p[78]="C:\\SmartEiffel\\lib\\numeric\\internal\\fraction_with_big_integer_number.e";
p[75]="C:\\SmartEiffel\\lib\\numeric\\internal\\integer_64_number.e";
p[76]="C:\\SmartEiffel\\lib\\numeric\\internal\\integer_general_number.e";
p[79]="C:\\SmartEiffel\\lib\\numeric\\internal\\fraction_general_number.e";
p[80]="C:\\SmartEiffel\\lib\\numeric\\internal\\big_integer_number.e";
p[60]="C:\\SmartEiffel\\lib\\string\\unicode_string.e";
p[3]="C:\\SmartEiffel\\lib\\string\\character.e";
p[7]="C:\\SmartEiffel\\lib\\string\\string.e";
p[31]="C:\\SmartEiffel\\lib\\string\\low_level\\string_handler.e";
p[108]="C:\\SmartEiffel\\lib\\time\\time_formatter.e";
p[90]="C:\\SmartEiffel\\lib\\time\\time.e";
p[86]="C:\\SmartEiffel\\lib\\time\\microsecond_time.e";
p[95]="C:\\SmartEiffel\\lib\\net\\access.e";
p[97]="C:\\SmartEiffel\\lib\\net\\socket_input_output_stream.e";
p[87]="C:\\SmartEiffel\\lib\\net\\low_level\\socket_server.e";
p[103]="C:\\SmartEiffel\\lib\\net\\low_level\\client_socket_input_output_stream.e";
p[96]="C:\\SmartEiffel\\lib\\net\\low_level\\server_socket_input_output_stream.e";
p[88]="C:\\SmartEiffel\\lib\\net\\low_level\\socket_plug_in.e";
p[89]="C:\\SmartEiffel\\lib\\net\\low_level\\socket_handler.e";
p[91]="C:\\SmartEiffel\\lib\\net\\low_level\\socket.e";
p[116]="C:\\SmartEiffel\\lib\\exec\\system.e";
se_prinT[123]=((void(*)(FILE*,void*))se_prinT123);
p[123]=p[54];
se_prinT[122]=((void(*)(FILE*,void*))se_prinT122);
p[122]=p[49];
se_prinT[61]=((void(*)(FILE*,void*))se_prinT61);
se_prinT[48]=((void(*)(FILE*,void*))se_prinT48);
se_prinT[47]=((void(*)(FILE*,void*))se_prinT47);
se_prinT[40]=((void(*)(FILE*,void*))se_prinT40);
se_prinT[25]=((void(*)(FILE*,void*))se_prinT25);
se_prinT[10]=((void(*)(FILE*,void*))se_prinT10);
se_prinT[9]=((void(*)(FILE*,void*))se_prinT9);
p[9]=p[54];
se_prinT[8]=((void(*)(FILE*,void*))se_prinT8);
se_prinT[7]=((void(*)(FILE*,void*))se_prinT7);
se_prinT[6]=((void(*)(FILE*,void*))se_prinT6);
se_prinT[3]=((void(*)(FILE*,void*))se_prinT3);
se_prinT[2]=((void(*)(FILE*,void*))se_prinT2);
se_prinT[1]=((void(*)(FILE*,void*))se_prinT1);
g[25]=(T7*)se_string("INTERFACE");
g[100]=(T7*)se_string("PROCEDURE");
g[94]=(T7*)se_string("MEMORY");
g[15]=(T7*)se_string("TUPLE 1");
g[16]=(T7*)se_string("TUPLE 2");
g[68]=(T7*)se_string("ROUTINE");
g[17]=(T7*)se_string("TUPLE 3");
g[18]=(T7*)se_string("TUPLE 4");
g[19]=(T7*)se_string("TUPLE 5");
g[20]=(T7*)se_string("TUPLE 6");
g[21]=(T7*)se_string("TUPLE 7");
g[22]=(T7*)se_string("TUPLE 8");
g[23]=(T7*)se_string("TUPLE 9");
g[14]=(T7*)se_string("TUPLE");
g[24]=(T7*)se_string("TUPLE 10");
g[8]=(T7*)se_string("POINTER");
g[99]=(T7*)se_string("REFERENCE");
g[67]=(T7*)se_string("FUNCTION");
g[6]=(T7*)se_string("BOOLEAN");
g[55]=(T7*)se_string("SAFE_EQUAL");
g[13]=(T7*)se_string("ANY");
g[101]=(T7*)se_string("WEAK_REFERENCE");
g[36]=(T7*)se_string("PLATFORM");
g[73]=(T7*)se_string("INTERNALS_HANDLER");
g[85]=(T7*)se_string("NATIVE_ARRAY_INTERNALS");
g[45]=(T7*)se_string("TYPED_INTERNALS");
g[51]=(T7*)se_string("NATIVE_ARRAY_COLLECTOR");
g[46]=(T7*)se_string("INTERNALS");
g[50]=(T7*)se_string("COLLECTION");
g[81]=(T7*)se_string("FAST_ARRAY");
g[49]=(T7*)se_string("ARRAY");
g[102]=(T7*)se_string("RING_ARRAY");
g[54]=(T7*)se_string("NATIVE_ARRAY");
g[93]=(T7*)se_string("RECYCLING_POOL");
g[52]=(T7*)se_string("ARRAYED_COLLECTION");
g[106]=(T7*)se_string("DIRECTORY_NOTATION");
g[53]=(T7*)se_string("FILTER");
g[26]=(T7*)se_string("OUTPUT_STREAM");
g[113]=(T7*)se_string("PATH_NAME");
g[71]=(T7*)se_string("FILTER_INPUT_STREAM");
g[38]=(T7*)se_string("TERMINAL_OUTPUT_STREAM");
g[104]=(T7*)se_string("FILE_TOOLS");
g[42]=(T7*)se_string("TERMINAL_INPUT_STREAM");
g[41]=(T7*)se_string("TERMINAL_INPUT_OUTPUT_STREAM");
g[63]=(T7*)se_string("FILTER_OUTPUT_STREAM");
g[43]=(T7*)se_string("INPUT_STREAM");
g[27]=(T7*)se_string("STREAM");
g[62]=(T7*)se_string("FILE");
g[61]=(T7*)se_string("TEXT_FILE_READ");
g[40]=(T7*)se_string("STD_INPUT_OUTPUT");
g[37]=(T7*)se_string("STD_ERROR");
g[48]=(T7*)se_string("STD_INPUT");
g[47]=(T7*)se_string("STD_OUTPUT");
g[44]=(T7*)se_string("INPUT_STREAM_TOOLS");
g[30]=(T7*)se_string("OUTPUT_STREAM_TOOLS");
g[39]=(T7*)se_string("REDIRECTION_TOOLS");
g[105]=(T7*)se_string("BASIC_DIRECTORY");
g[115]=(T7*)se_string("UNIXISH_PATH_NAME");
g[29]=(T7*)se_string("FILTERABLE");
g[112]=(T7*)se_string("PATH_JOINER");
g[114]=(T7*)se_string("POSIX_PATH_NAME");
g[111]=(T7*)se_string("PATH_NAME_NOTATION");
g[109]=(T7*)se_string("MACINTOSH_DIRECTORY_NOTATION");
g[117]=(T7*)se_string("OPENVMS_DIRECTORY_NOTATION");
g[120]=(T7*)se_string("MICROSOFT_PATH_NAME");
g[119]=(T7*)se_string("WINDOWS_DIRECTORY_NOTATION");
g[110]=(T7*)se_string("UNIX_DIRECTORY_NOTATION");
g[118]=(T7*)se_string("AMIGA_DIRECTORY_NOTATION");
g[121]=(T7*)se_string("CYGWIN_DIRECTORY_NOTATION");
g[107]=(T7*)se_string("UNICODE_STRING_HANDLER");
g[66]=(T7*)se_string("ITERATOR");
g[74]=(T7*)se_string("ITERATOR_ON_TRAVERSABLE");
g[82]=(T7*)se_string("ITERATOR_ON_UNICODE_STRING");
g[70]=(T7*)se_string("ITERATOR_ON_STRING");
g[84]=(T7*)se_string("MINI_PARSER_BUFFER");
g[83]=(T7*)se_string("EVENTS_SET");
g[64]=(T7*)se_string("EVENT_DESCRIPTOR");
g[72]=(T7*)se_string("CAN_READ_DATA_FROM_STREAM");
g[98]=(T7*)se_string("NETWORK_CONNECTION_OCCURRED");
g[65]=(T7*)se_string("CAN_WRITE_DATA_TO_STREAM");
g[28]=(T7*)se_string("RECYCLABLE");
g[92]=(T7*)se_string("DISPOSABLE");
g[32]=(T7*)se_string("TRAVERSABLE");
g[35]=(T7*)se_string("HASHABLE");
g[33]=(T7*)se_string("STORABLE");
g[34]=(T7*)se_string("COMPARABLE");
g[12]=(T7*)se_string("REAL_EXTENDED");
g[58]=(T7*)se_string("REAL_GENERAL");
g[2]=(T7*)se_string("INTEGER_32");
g[59]=(T7*)se_string("NUMBER");
g[4]=(T7*)se_string("REAL_32");
g[1]=(T7*)se_string("INTEGER_8");
g[77]=(T7*)se_string("MUTABLE_BIG_INTEGER");
g[11]=(T7*)se_string("INTEGER_64");
g[69]=(T7*)se_string("NUMBER_TOOLS");
g[56]=(T7*)se_string("INTEGER_GENERAL");
g[5]=(T7*)se_string("REAL_64");
g[57]=(T7*)se_string("NUMERIC");
g[10]=(T7*)se_string("INTEGER_16");
g[78]=(T7*)se_string("FRACTION_WITH_BIG_INTEGER_NUMBER");
g[75]=(T7*)se_string("INTEGER_64_NUMBER");
g[76]=(T7*)se_string("INTEGER_GENERAL_NUMBER");
g[79]=(T7*)se_string("FRACTION_GENERAL_NUMBER");
g[80]=(T7*)se_string("BIG_INTEGER_NUMBER");
g[60]=(T7*)se_string("UNICODE_STRING");
g[3]=(T7*)se_string("CHARACTER");
g[7]=(T7*)se_string("STRING");
g[31]=(T7*)se_string("STRING_HANDLER");
g[108]=(T7*)se_string("TIME_FORMATTER");
g[90]=(T7*)se_string("TIME");
g[86]=(T7*)se_string("MICROSECOND_TIME");
g[95]=(T7*)se_string("ACCESS");
g[97]=(T7*)se_string("SOCKET_INPUT_OUTPUT_STREAM");
g[87]=(T7*)se_string("SOCKET_SERVER");
g[103]=(T7*)se_string("CLIENT_SOCKET_INPUT_OUTPUT_STREAM");
g[96]=(T7*)se_string("SERVER_SOCKET_INPUT_OUTPUT_STREAM");
g[88]=(T7*)se_string("SOCKET_PLUG_IN");
g[89]=(T7*)se_string("SOCKET_HANDLER");
g[91]=(T7*)se_string("SOCKET");
g[116]=(T7*)se_string("SYSTEM");
g[123]=g[54];
g[122]=g[49];
g[9]=g[54];
t[123]=(T7*)se_string("NATIVE_ARRAY[STRING]");
t[122]=(T7*)se_string("ARRAY[STRING]");
t[61]=g[61];
t[48]=g[48];
t[47]=g[47];
t[40]=g[40];
t[25]=g[25];
t[10]=g[10];
t[9]=(T7*)se_string("NATIVE_ARRAY[CHARACTER]");
t[8]=g[8];
t[7]=g[7];
t[6]=g[6];
t[3]=g[3];
t[2]=g[2];
t[1]=g[1];
#ifdef SIGINT
signal(SIGINT,se_signal_handler);
#endif
#ifdef SIGTERM
signal(SIGTERM,se_signal_handler);
#endif
#ifdef SIGQUIT
signal(SIGQUIT,se_signal_handler);
#endif
#ifdef SIGILL
signal(SIGILL,se_signal_handler);
#endif
#ifdef SIGABRT
signal(SIGABRT,se_signal_handler);
#endif
#ifdef SIGFPE
signal(SIGFPE,se_signal_handler);
#endif
#ifdef SIGSEGV
signal(SIGSEGV,se_signal_handler);
#endif
#ifdef SIGBUS
signal(SIGBUS,se_signal_handler);
#endif
#ifdef SIGSYS
signal(SIGSYS,se_signal_handler);
#endif
#ifdef SIGTRAP
signal(SIGTRAP,se_signal_handler);
#endif
#ifdef SIGXCPU
signal(SIGXCPU,se_signal_handler);
#endif
#ifdef SIGXFSZ
signal(SIGXFSZ,se_signal_handler);
#endif
gc_is_off=0;
tmp0=((T0*)(new25()));
eiffel_root_object=((T25*)tmp0);
set_dump_stack_top((void*)0);/*unlink*/
}/*--*/

int main(int argc,char*argv[]){
/*[INTERNAL_C_LOCAL list*/
T0* tmp0;
/*INTERNAL_C_LOCAL list]*/
se_frame_descriptor root={"<system root>",1,0,"%R25%",1};
se_dump_stack ds;
stack_bottom=((void**)(void*)(&argc));
initialize_eiffel_runtime(argc,argv);
tmp0=((T0*)eiffel_root_object);
ds.fd=&root;
ds.current=((void*)(&tmp0));
ds.p=0x03201604/*l22c2\interface.e*/;
ds.caller=NULL;
ds.exception_origin=NULL;
ds.locals=NULL;
set_dump_stack_top(&ds);/*link*/
r25main(&ds,((T25*)tmp0));
handle(SE_HANDLE_NORMAL_EXIT, NULL);
set_dump_stack_top(NULL);/*unlink*/
exit(0);
return 0;
}/*--*/

#ifdef __cplusplus
}
#endif
